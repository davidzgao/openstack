// Copyright (c) 2014. This file is confidential and proprietary.
// All Rights Reserved, Microchild Technologies (http://www.microchild.com)

var mockRedisStore = {};

var mockRedisClient = {
    _setRedisStore: function(redisStore) {
        mockRedisStore = {};
        mockRedisStore = redisStore;
    },
    _getRedisStore: function() {
        return mockRedisStore;
    },
    _initValues: function() {
        this.values = [];
    },
    _getValues: function() {
        return this.values;
    },
    _setValues: function(val) {
        if(this.values === undefined) {
            return;
        } else {
            this.values.push(val);
        }
    },
    DEL: function(key, callback) {
        var result = key in mockRedisStore;
        delete mockRedisStore[key];
        if(callback) {
            callback(null, result);
        }
        this._setValues(result);
        return this;
    },
    GET: function(key, callback) {
        var result = (key in mockRedisStore) ? mockRedisStore[key] : null;
        if(callback) {
            callback(null, result);
        }
        this._setValues(result);
        return this;
    },
    HGET: function(hash, key, callback) {
        var val = (key in hash) ? hash[key] : null;
        if(callback) {
            callback(null, val);
        }
        this._setValues(val);
        return this;
    },
    HGETALL: function(key, callback) {
        var result = (key in mockRedisStore) ? mockRedisStore[key] : null;
        if(callback) {
            callback(null, result);
        }
        this._setValues(result);
        return this;
    },
    HMGET: function() {
        var hashName = arguments[0];
        var mockHash = mockRedisStore[hashName] || {};
        var vals = [];
        for(var i = 1; i < arguments.length; i++) {
            if ('function' !== typeof arguments[i]) {
                var value = mockHash[arguments[i]];
                if(value === undefined) {
                    value = null;
                }
                vals.push(value);
            } else {
                break;
            }
        }
        if(typeof(arguments[arguments.length - 1]) === 'function') {
            arguments[arguments.length - 1](null, vals);
        }
        this._setValues(vals);
        return this;
    },
    sort: function(sortParams, callback) {
        var result = [];
        for(var key in mockRedisStore) {
            var obj = mockRedisStore[key];
            for(var keyField in sortParams) {
                var sortParam = sortParams[keyField];
                for(var keyObj in obj) {
                    if(sortParam.split('->').length > 1 &&
                       keyObj === sortParam.split('->')[1]) {
                        result.push(obj[keyObj]);
                        break;
                    }
                }
            }
        }
        if(callback) {
            callback(null, result);
        }
        return this;
    },
    HMSET: function(hashName, hash, callback) {
        if(!(hashName in mockRedisStore)) {
            mockRedisStore[hashName] = {};
        }
        for(var key in hash) {
            mockRedisStore[hashName][key] = hash[key];
        }
        if(callback) {
            callback(null, 1);
        }
        this._setValues(1);
        return this;
    },
    HKEYS: function(hashName, callback) {
        var mockHash = mockRedisStore[hashName] || {};
        var keys = [];
        for(var key in mockHash) {
            keys.push(key);
        }
        if(callback) {
            callback(null, keys);
        }
        this._setValues(1);
        return this;
    },
    SDIFF: function(orgSet, newSet, callback) {
        var orgSetVals = mockRedisStore[orgSet];
        var newSetVals = mockRedisStore[newSet];
        var diffVals = diffArray(orgSetVals, newSetVals);
        if(callback) {
            callback(null, diffVals);
        }
        this._setValues(diffVals);
        return this;
    },
    SADD: function(setName, setVal, callback) {
        if(mockRedisStore[setName] !== undefined) {
            mockRedisStore[setName].push(setVal);
        } else {
            mockRedisStore[setName] = [setVal];
        }
        if(callback) {
            callback(null);
        }
        this._setValues(null);
        return this;
    },
    SREM: function(setName, setVal, callback) {
        if(mockRedisStore[setName] !== undefined) {
            removeArrayItem(mockRedisStore[setName], setVal);
        }
        if(callback) {
            callback(null);
        }
        this._setValues(null);
        return this;
    },
    multi: function() {
        this._initValues();
        return this;
    },
    exec: function(callback) {
        callback(null, this._getValues());
    }
};
exports.mockRedisClient = mockRedisClient;

/**
 * Function which returns the result of the subtraction method applied to
 * sets (mathematical concept).
 *
 * @param a Array one
 * @param b Array two
 * @return An array containing the result
 */
function diffArray(a, b) {
  var seen = [], diff = [];
  for ( var i = 0; i < b.length; i++)
      seen[b[i]] = true;
  for ( var i = 0; i < a.length; i++)
      if (!seen[a[i]])
          diff.push(a[i]);
  return diff;
}

function removeArrayItem(arr, item) {
    var index = arr.indexOf(item);
    if(index > -1) {
        arr.splice(index, 1);
    }
}
