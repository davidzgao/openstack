// Copyright (c) 2014. This file is confidential and proprietary.
// All Rights Reserved, Microchild Technologies (http://www.microchild.com)

'use strict';

/**
 *  Module: query-storage-utils.js
 *
 * Collection of functions for querying storage.
 */
var async = require('async');
var utils = require('./storage-utils');
var jsonutils = require('./jsonutils');
var searchHash = require('./searchHash');

var log = require('./logger');
var logger = log.setLogger();

var setLogger = function(exLogger) {
    logger = log.setLogger(exLogger);
};
exports.setLogger = setLogger;

/**
 * Options include following items:
 *
 *   * `sort_field`: Optional, default is created
 *   * `query`: Required, query conditions, object
 *   * `limit`: Optional
 *
 * @param {Object} obj Storage object
 * @param {Function} callback Callback Function
 */
function initialize(obj, options) {
    if(options['resource_type'] === undefined) {
        throw 'No query resource type defined.';
    }

    var newObj = {};
    for(var key in obj) {
        newObj[key] = obj[key];
    }
    newObj.resourceType = options['resource_type'];
    newObj.fields = options['fields'];
    newObj.sortField = options['sort_field'] || 'created';
    newObj.query = options['query'] || {};
    newObj.limit = options['limit'] || {};
    newObj.queryCons = options['query_cons'] || {};
    newObj.reverseItems = options['reverse_items'] || [];
    newObj.requireDetail = options['require_detail'] || false;
    newObj.conditionRelation = options['condition_relation'] || {};

    return newObj;
}
exports.initialize = initialize;

/**
 * Query a single object.
 *
 * @param {Object} obj Storage object
 * @param {Function} callback Callback Function
 */
function queryObject(obj, callback) {
    var hashKey = utils.getObjectHashName(
            obj.resourceType, obj.objectId);
    obj.redisClient.HGETALL(hashKey, function(error, data) {
        callback(error, data);
    });
} // end queryObject
exports.queryObject = queryObject;

/**
 * Query several objects.
 *
 * @param {Object} obj Storage object
 * @param {Function} callback Callback Function
 */
function queryObjects(obj, callback) {
    var resourceIds = [];

    var sortParams = getSortParams({
        resourceType: obj.resourceType,
        sortField: obj.sortField,
        query: obj.query,
        insertId: true,
        isDesc: true
    });

    obj.redisClient.sort(sortParams, function(err, replies) {
        if(err) {
            callback(err);
            return;
        }
        logger.debug('Get %s successfully, resource length is %s',
            obj.resourceType, replies.length);

        resourceIds = filterResourceIds(obj, replies);
        getObjectsByKeys(obj, resourceIds, function(error, replies) {
            callback(error, replies);
        });
    });
}
exports.queryObjects = queryObjects;

/**
 * Query several objects by ids.
 *
 * @param {Object} obj Storage object
 * @param {Function} callback Callback Function
 */
function queryObjectsByIds(obj, callback) {
    var sortParams = getSortParams({
        resourceType: obj.resourceType,
        fields: obj.fields,
        insertId: true,
        isDesc: false
    });

    obj.redisClient.sort(sortParams, function(err, replies) {
        var fieldsCount = obj.fields.length;
        var res = {};
        if(err) {
            callback(err);
            return;
        }
        logger.debug('Get %s successfully, resource length is %s',
            obj.resourceType, replies.length);

        // We assume that the length of replies is a multiple
        // of (fieldsCount + 1).
        if (replies.length % (fieldsCount + 1) != 0) {
            err = "Get fields error"
            callback(err, undefined)
            return
        }
        for(var rep = 0; rep < replies.length; rep ++) {
            for(var idx in obj.ids) {
                if(obj.ids[idx] == replies[rep + fieldsCount]) {
                    var resItem = {};
                    for(var ind in obj.fields) {
                        ind = Number(ind);
                        resItem[obj.fields[ind]] = replies[rep + ind];
                    }
                    res[obj.ids[idx]] = resItem;
                    break;
                }
            }
            rep += fieldsCount;
        }
        callback(err, res);
    });
}
exports.queryObjectsByIds = queryObjectsByIds;

/**
 * Get object ids by conditions.
 *
 * If our query conditions looks like:
 *
 *   {
 *     'tenant_id': 123.
 *     'status': 'ACTIVE'
 *   }
 *
 * The reply list will be:
 *
 *   ['123', 'ACTIVE', 12345, '456', 'ACTIVE', 20000]
 *
 * Update: 2015/08/06
 *   Add filter for "Logical negation";
 *   If the string in array for reverse match,
 *   it's open 'negative' model for query.
 *
 * The return order is tenant_id, status, id.
 *
 * We need to get the ids whose values equal to tenant_id and
 * status, this example will only return [12345].
 */
function filterResourceIds(obj, records) {
    var matchIds = [];
    var reverseItems = obj.reverseItems;

    var isMatch;
    for(var index = 0; index < records.length; index++) {
        isMatch = true;
        // compare result with query condition, as the last field
        // is id, we do not need to compare
        for(var field in obj.query) {
            var model = 'positive';
            var value = obj.query[field];
            var valueArray = [];
            if(reverseItems.length > 0) {
                if(reverseItems.indexOf(field) != -1) {
                    model = 'negative';
                }
            }
            if(model == 'positive') {
                if(records[index] != value) {
                    isMatch = false;
                }
            } else if(model == 'negative') {
                valueArray = valueArray.concat(value);
                valueArray.forEach(function (item) {
                    if(records[index] == item) {
                        isMatch = false;
                    }
                });
            }
            index++;
        }
        if(isMatch) {
            matchIds.push(records[index]);
        }
    }
    return matchIds;
} // end function filterResourceIds

/**
 * Get objects by query keys.
 *
 * Filter objects ids by limitation, after that, query
 * objects detail with async function.
 */
function getObjectsByKeys(obj, resourceIds, callback) {
    var redisClient = obj.redisClient;
    var hashKeys = [];
    var replies = [];

    var total = 0;
    // collect object ids
    for(var index in resourceIds) {
        if(!resourceIds[index]) {
            continue;
        }
        total++;
        if(obj.limit) {
            if(total < obj.limit.from || total >= obj.limit.to) {
                continue;
            }
        } // end if limit
        hashKeys.push(
            utils.getObjectHashName(
                obj.resourceType, resourceIds[index])
        );
    } // end for index

    // query objects detail.
    async.each(hashKeys, function(hashKey, callback) {
        redisClient.HGETALL(hashKey, function(err, data) {
            replies.push(data);
            callback(err, data);
        });
    }, function(err) {
        var result = {
            'total': total,
            'data': replies
        };
        callback(err, result);
    }); // end async.each
} // end function getObjectsByKeys

/**
 * Query several objects by values.
 *
 * @param {Object} obj Storage object
 * @param {Function} callback Callback Function
 */
function queryObjectsByKeyValues(obj, callback) {
    var queryCons = obj.queryCons;
    var conditionRelation = obj.conditionRelation;
    var queryKeys = [];
    var res = {};
    var resIds = [];
    for(var key in queryCons) {
        queryKeys.push(key);
    }
    var sortParams = getSortParams({
        resourceType: obj.resourceType,
        fields: queryKeys,
        insertId: true,
        idDesc: false
    });

    obj.redisClient.sort(sortParams, function(err, replies) {
        var indexOfQueryKeys = 0;
        var matchResult = {};
        if(err) {
            callback(err);
            return;
        }
        logger.debug('Get %s successfully, resource length is %s',
            obj.resourceType, replies.length);

        for(var indexOfReplies in replies) {
            indexOfReplies = Number(indexOfReplies);
            var reply = replies[indexOfReplies];
            var curIndexOfQueryKeys = indexOfQueryKeys;
            var curQueryKey = queryKeys[curIndexOfQueryKeys];
            var values = queryCons[curQueryKey];

            if(indexOfQueryKeys == queryKeys.length) {
                indexOfQueryKeys = 0;
                matchResult = {};
                continue;
            }// end if indexOfQueryKeys equals to queryKeys' length
            indexOfQueryKeys++;

            try{
                if(isResultMatchQueryValues(reply, curQueryKey, values)) {
                    var resItem = {};
                    var resId = replies[indexOfReplies
                        + (queryKeys.length -curIndexOfQueryKeys)];
                    resItem[curQueryKey] = replies[indexOfReplies];
                    if(conditionRelation == "and") {
                        if(indexOfQueryKeys < queryKeys.length) {
                            matchResult[curQueryKey] =
                                replies[indexOfReplies];
                            continue;
                        }else if(indexOfQueryKeys == queryKeys.length) {
                            var jsonLength =
                                jsonutils.getJsonLength(matchResult);
                            if(jsonLength == queryKeys.length -1) {
                                matchResult[curQueryKey] =
                                    replies[indexOfReplies];
                                resIds.push(resId);
                                res[resId] = matchResult;
                                continue;
                            }else{
                                continue;
                            }
                        }
                    }else{
                        resIds.push(resId);
                        res[resId] = resItem;
                        continue;
                    }
                }
            } catch(err) {
                callback(err);
            }
            }
            if(obj.requireDetail) {
                getObjectsByKeys(obj, resIds, function(err, objs) {
                    callback(err, objs);
                });
            }else{
                var total = 0;
                var resArray = [];
                for (var item in res) {
                    total++;
                    if(obj.limit) {
                        if(total < obj.limit.from || total >= obj.limit.to) {
                            continue;
                        }
                    } // end if limit
                    var itemObj = res[item];
                    itemObj.id = item;
                    resArray.push(itemObj);
                }
                var resBody = {
                  'total': total,
                  'data': resArray
                }
                callback(err, resBody);
            }
    });
}
exports.queryObjectsByKeyValues = queryObjectsByKeyValues;

/**
 * Get sortParams by resourceType, query keys and insertId
 *
 * If want the descend order of result set isDesc to true.
 */
function getSortParams(obj){
    var sortParams = [
        utils.getObjectSet(obj.resourceType)
    ];
    if(obj.sortField) {
        sortParams.push('BY');
        sortParams.push(utils.getSortField(
            obj.resourceType, obj.sortField));
    }

    for(var key in obj.fields) {
        var field = obj.fields[key];
        sortParams.push('GET');
        if (field.indexOf('@') < 0) {
            sortParams.push(utils.getSortField(
                obj.resourceType, field));
        }else{
            field = field.split("@")[0];
            sortParams.push(utils.getSortField(
                obj.resourceType, field));
        }
    }
    for(var field in obj.query) {
        sortParams.push('GET');
        if (field.indexOf('@') < 0) {
            sortParams.push(utils.getSortField(
                obj.resourceType, field));
        }else{
            field = field.split("@")[0];
            sortParams.push(utils.getSortField(
                obj.resourceType, field));
        }
    }

    if(obj.insertId) {
        // insert id at the end of each record, use to split query result
        sortParams.push('GET');
        sortParams.push(utils.getSortField(obj.resourceType, 'id'));
        sortParams.push('ALPHA');
    }
    if(obj.isDesc) {
        sortParams.push('DESC');
    }
    return sortParams;
}

/**
 * Check if the result macth the value of key to query.
 */
function isResultMatchQueryValues(result, queryKey, queryValues){
    if(queryKey.indexOf('@') >= 0) {
        var keysSplit = queryKey.split('@');
        var keysRev = keysSplit.reverse();
        keysRev.pop();
        var valueOfKeyInHash = searchHash.getValueOfHashKey(result, keysRev);
        if(valueOfKeyInHash === undefined) {
             return false;
        }else{
             result = valueOfKeyInHash;
        }
    }

    result = String(result);
    for(var indexOfValues in queryValues) {
        var val = queryValues[indexOfValues];
        if(result.indexOf(val) >= 0) {
            return true;
        }
     }
     return false;
}
