// Copyright (c) 2014. This file is confidential and proprietary.
// All Rights Reserved, Microchild Technologies (http://www.microchild.com)

/**
 *  Module: redis.js
 *
 * Collection of functions for dealing with redis.
 */

var redis = require('redis');
var uuid = require('node-uuid');
var async = require('async');
var jsonutils = require('./jsonutils');

var log = require('./logger');
var logger = log.setLogger();

var setLogger = function(exLogger) {
    logger = log.setLogger(exLogger);
};
exports.setLogger = setLogger;

/**
 * Basic Functions
 */

/**
 * Connect to redis.
 *
 * The options has the following values:
 *
 *   * `redis_port`: Redis connection port
 *   * `redis_host`: Redis connection host
 *   * `redis_password`: Redis connection password
 *   * `debug`: if debug
 *
 * @param {Object} options Options, see detailed above.
 * @param {Function} callback Callback function.
 */
var connect = function(options, callback) {
    var options = options || {};
    var redisHost = options['redis_host'] || '127.0.0.1';
    var redisPort = options['redis_port'] || 6379;
    var redisPassword = options['redis_password'] || '';
    var debug = options['debug'] || false;

    logger.debug('Connecting Redis %s:%s...', redisHost, redisPort);

    // if redis connection is lost, retry connection delay 5s
    var redisClient = redis.createClient(
            redisPort, redisHost, {'retry_max_delay': 5000});

    redisClient.on('error', function(err) {
        logger.error('Redis connection error: ', err);
        logger.error('Retrying to connect redis...');
    }); // end redisClient.on('error')

    redisClient.on('connect', function() {
        if(redisPassword) {
            redisClient.auth(redisPassword, function(err, res) {
                if(err) {
                    throw Error('Error happend while require auth', err);
                }
            }); // end redisClient.auth
        }

        if(callback) {
            callback(redisClient);
            return;
        }
    }); // end redisClient.on('connect')

    return redisClient;
}
exports.connect = connect;

/**
 * This is a wrapper to redis.print. Make our wrapper redis
 * take the same effect as redis.print.
 */
var print = function() {
    return redis.print;
}
exports.print = print();

/**
 * Queue Functions
 */

/**
 * Places the `data` wrapped in a structure at the end of the list
 *
 * The options has the following values:
 *
 *   * `queue` - Queue name for message publish
 *   * `data` - Message context
 *   * `redis_client` - Optinal, Client for redis connection, if this is not given
 *                      try to connect redis on the localhost
 *
 * The object placed on the queue has the following values:
 *
 *   * `id` - A unique identification value, uuid
 *   * `created` - A timestamp when this message was first placed on the queue.
 *   * `updated` - If a `created` property already exists, then this is added/updated.
 *   * `payload` - The contents of the `data` parameter.
 *
 * @param {Object} options Options, see detailed above.
 * @param {Function} callback Executed after the push. This function is given
 *                   the object placed on the queue.
 */
var publish = function(options, callback) {
    var data = options['data'];
    var queue = options['queue'];
    var redisClient = options['redis_client'] || this.connect();
    var debug = options['debug'] || false;
    var body = formatMessage(data);

    logger.info('Publishing to queue [%s] with message %s',
            queue, JSON.stringify(body));

    redisClient.RPUSH(queue, JSON.stringify(body), function(err, reply) {
        if (callback) {
            callback(formatCallbackMessage(err, reply, body));
        }
    }); // end redisClient.RPUSH
}; // end var publish
exports.publish = publish;

/**
 * Places the `data` wrapped in a structure at the beginning of the list
 *
 * The options has the following values:
 *
 *   * `queue` - Queue name for message publish
 *   * `data` - Message context
 *   * `redis_client` - Optinal, Client for redis connection, if this is not given
 *                      try to connect redis on the localhost
 *
 * The object placed on the queue has the following values:
 *
 *   * `id` - A unique identification value, uuid
 *   * `created` - A timestamp when this message was first placed on the queue.
 *   * `updated` - If a `created` property already exists, then this is added/updated.
 *   * `payload` - The contents of the `data` parameter.
 *
 * @param {Object} options Options, see detailed above.
 * @param {Function} callback Executed after the push. This function is given
 *                   the object placed on the queue.
 */
var jump = function(options, callback) {
    var data = options['data'];
    var queue = options['queue'];
    var redisClient = options['redis_client'] || this.connect();
    var debug = options['debug'] || false;
    var body = formatMessage(data);

    logger.info('Jumping message to queue [%s] with message %s',
            queue, JSON.stringify(body));

    redisClient.LPUSH(queue, JSON.stringify(body), function(err, reply) {
        if (callback) {
            callback(formatCallbackMessage(err, reply, body));
        }
    }); // end redisClient.LPUSH
}; // end var jump
exports.jump = jump;

/**
 * The data given to us, could be a generated data, like { a:1, b:2 }
 * Or, it could be a complete message that was taken off the queue,
 * processed, and is being put back on the queue.
 *
 * We identify 'messages' by having `id` and `created` properties:
 *
 * @param {Object} data Message to format.
 */
function formatMessage(data) {
    var body = {};

    data = jsonutils.parseJson(data);

    if(data.id && data.created) {
        body = data;
        body.updated = new Date().getTime();
    } else {
        body = {
            'id': uuid.v1(),
            'created': new Date().getTime(),
            'payload': data
        };
    } // end if data.id && data.created

    return body;
} // end function formatMessage

/**
 * Add results to the callback message.
 *
 * @param {String} err Error message
 * @param {Object} reply Reply message
 * @param {Object} body Message to callback
 */
function formatCallbackMessage(err, reply, body) {
    if (err) {
        body.results = 'error';
        body.error = err;
    }
    if (reply) {
        body.results = 'ok';
        delete body.error;
    }
    return body;
} // end function formatCallbackMessage

/**
 * Blocks until a message of the given name is available.
 *
 * The options has the following values:
 *
 *   * `queues` - Queue name(s) for message recieve, this could be an Array or string
 *   * `redis_client` - Optinal, Client for redis connection, if this is not given
 *                      try to connect redis on the localhost
 *
 * @param {Object} options Options, see detailed above
 * @param {Function} callback Called with the object popped from the queue.
 */
var subscribe = function(options, callback) {
    var redisClient = options['redis_client'] || this.connect();
    var queueNames = options['queues'] || [];
    var debug = options['debug'] || false;
    var popArguments = [];

    // The Redis BLPOP command takes a list of queue names as individual
    // parameters (not as an array). To fix this, we create a new array with
    // all of the arguments in an array, and we'll call BLPOP with `apply`.
    if(typeof queueNames !== 'object') {
        popArguments = [queueNames];
    } else {
        // We have an original(new) message
        for(var n in queueNames) {
            popArguments.push(queueNames[n]);
        }
    }

    // The timeout is set forever
    popArguments.push(0);
    popArguments.push(function(err, body) {
        callitback(callback, err, body);
    });

    logger.info('Receiving message from queue [%s]...', queueNames);

    redisClient.blpop.apply(redisClient, popArguments);
};
exports.subscribe = subscribe;

/**
 * The behavior function for how we will call the callback given to `subscribe`.
 *
 * When a message comes from the queue, we need to update the value before
 * sending it to the callback function.
 *
 * @param {Function} callback  Given to us by the caller of `receive`
 * @param {String}   err       Error message if a problem occurred. Null otherwise.
 * @param {Array}    body      Tuple: [0] is the name of the queue, and [1] is the
 *                             string containing the body
 */
function callitback(callback, err, body) {
    var data = {};
    var queueName = null;
    if(body !== undefined) {
        data = jsonutils.parseJson(body[1]);
        queueName = body[0];
    }
    if(err) {
        data.results = 'error';
        data.error = err;
    } else {
        data.results = 'ok';
    }
    callback(queueName, data);
}
