// Copyright (c) 2014. This file is confidential and proprietary.
// All Rights Reserved, Microchild Technologies (http://www.microchild.com)

'use strict';

/**
 *  Module: save-storage-utils.js
 *
 * Collection of functions for saving storage.
 */

var async = require('async');
var jsonutils = require('./jsonutils');
var utils = require('./storage-utils');
var timeutils = require('./timeutils');

var log = require('./logger');
var logger = log.setLogger();

var setLogger = function(exLogger) {
    logger = log.setLogger(exLogger);
};
exports.setLogger = setLogger;

// max workers for async queue
var MAX_WORKER = 10;

// Fetch at field name
var FETCH_AT_FIELD = 'fetch_at';

/**
 * Options include following items:
 *
 *   * `id_field`: Optional, id field of object, by default is id
 *   * `update_field`: Optional, update field of object, by default is
 *                     updated
 *   * `hash_prefix`: Required, basic name for all the hash and set
 *   * `data`: Required, objects data
 *   * `fieldMap`: field map to mapping field to the name we want
 *   * `debug`: Optional, if debug, default is false
 */
function initialize(obj, options) {
    if(options['hash_prefix'] === undefined) {
        throw new Error('No hash prefix defined.');
    }

    obj.fieldMap = options['field_map'] || {};
    obj.idField = options['id_field'] || 'id';
    obj.updateField = options['update_field'] || 'updated';
    obj.hashPrefix = options['hash_prefix'];
    obj.data = options['data'] || {};
    obj.fetchAt = options['fetch_at'] || new Date().getTime();
    obj.needFresh = options['need_fresh'] || false;

    return obj;
}
exports.initialize = initialize;


/**
 * Init objects in redis.
 *
 * Remove temporary set
 */
function initObjects(obj, callback) {
    obj.redisClient.multi()
        .DEL(utils.getNewObjectSet(obj.hashPrefix))
        .exec(function(err, replies) {
            callback(err, replies);
        });
} // end function initObjects
exports.initObjects = initObjects;

/**
 * Parallel to update hash and set in redis in objects iteration.
 */
function setObjects(obj, callback) {
    var setQueue = async.queue(function(ops, callback) {
        saveObject(ops['obj'], ops['data'], callback);
    }, MAX_WORKER);

    setQueue.drain = function() {
        callback(null, null);
    }

    if(obj.data.length === 0) {
        logger.debug('No data found.');
        callback(null);
    } else {
        for(var index in obj.data) {
            setQueue.push({
                'obj': obj,
                'data': obj.data[index]
            }); // end setQueue.push
        } // end for
    } // end if
} // end function setObjects
exports.setObjects = setObjects;

/**
 * Clean set and index for object.
 *
 * Compare old object set and new object, if any records found, remove
 * related hash in redis.
 */
function cleanObjects(obj, callback) {
    var redisClient = obj.redisClient;
    var objectSet = utils.getObjectSet(obj.hashPrefix);
    var newObjectSet = utils.getNewObjectSet(obj.hashPrefix);

    redisClient.SDIFF(objectSet, newObjectSet,
            function(err, extraIds) {
        if(extraIds.length) {
            var cleanQueue = async.queue(function(ops, callback) {
                removeObject(ops['obj'], ops['object_id'], callback);
            }); // end cleanQueue

            cleanQueue.drain = function() {
                callback();
            }

            for(var n in extraIds) {
                cleanQueue.push({
                    'obj': obj,
                    'object_id': extraIds[n]
                });
            }
        } else {
            callback(err, null);
        } // end if replies.length
    }); // end redisClient.SDIFF
} // end function cleanObjects
exports.cleanObjects = cleanObjects;

/**
 * Remove objects from redis. Include hash and set.
 */
function removeObject(obj, objectId, callback) {
    var hashName = utils.getObjectHashName(obj.hashPrefix, objectId);
    var objectSet = utils.getObjectSet(obj.hashPrefix);

    // create a data object only with id field and update field
    var data = {};
    data[obj.idField] = objectId;

    isValueExpired(obj, data, function(isExpired) {
        // only delete data if it's not expired
        if(isExpired) {
            logger.debug('Cleanning hash %s...', hashName);
            logger.debug('Cleanning %s from set %s',
                objectId, objectSet);
            obj.redisClient.multi()
                .DEL(hashName)
                .SREM(objectSet, objectId)
                .exec(function(err, replies) {
                    callback(err);
                });
        } else {
            callback(null);
        } // end isExpired
    });
} // end function removeObject
exports.removeObject = removeObject;

/**
 * Main Function to save object.
 *
 * This will include two steps: save hash and save set.
 *
 * To avoid race condition of mutliple workers to update the same hash.
 * Before each update, we should compare with updated or fetchat, update
 * hash only if the given one is newer than the store one.
 */
function saveObject(obj, data, callback) {
    var id = data[obj.idField];
    var hashName = utils.getObjectHashName(obj.hashPrefix, id);

    data[FETCH_AT_FIELD] = obj.fetchAt;
    var formatData = jsonutils.toJsonString(data, obj.fieldMap);

    isValueExpired(obj, data, function(isExpired) {
        if(isExpired) {
            updateHash(obj.redisClient, hashName,
                formatData, obj.debug, function(error) {
                // update set after update hash
                updateSet(obj, data, function(error) {
                    callback(error);
                });
            });
        } else {
            updateTempSet(obj, data, function(error) {
                callback(error);
            });
        } // end if isExpired
    });
} // end function saveObject
exports.saveObject = saveObject;

/**
 * Return true if hash value is already expired.
 *
 */
function isValueExpired(obj, data, callback) {
    var objectId = data[obj.idField];
    var hashName = utils.getObjectHashName(obj.hashPrefix, objectId);
    var freshDate = data[obj.updateField];

    obj.redisClient.HMGET(hashName, obj.updateField, FETCH_AT_FIELD,
            function(err, replies) {
        var updateAt = replies[0];
        var fetchAt = replies[1];

        var storeDate = updateAt;
        if(updateAt === null || freshDate === undefined) {
            logger.debug('No update field found, ' +
                'use task timestamp.');
            storeDate = fetchAt;
            freshDate = obj.fetchAt;
        }

        logger.debug('storeDate is %s, freshDate is %s, ' +
            'expired is %s.', storeDate, freshDate,
            timeutils.isExpired(storeDate, freshDate, obj.needFresh));
        if(storeDate === null ||
                timeutils.isExpired(storeDate, freshDate, obj.needFresh)) {
            /**
            * Can not get update value, it means this record is never set
            * or the hash keys have changed, set hash here
            * In format data we will add mapping fields into our data,
            * so here we should compare with the formated data
            */
            callback(true);
        } else {
            logger.debug('Stored Hash %s data is not expired.',
                    hashName);
            // new data is expired, we do not need to update it anymore
            callback(false);
        } // end if storeDate === null
    });
} // end function isValueExpired

/**
 * Update set for object.
 *
 * For sorted set, by default, we will use created as sorted score. If no
 * create field provide, we will give a 0 as score for sorted hash.
 *
 */
function updateSet(obj, data, callback) {
    var id = data[obj.idField];
    var objectSet = utils.getObjectSet(obj.hashPrefix);

    obj.redisClient.SADD(objectSet, id, function(err) {
        if(!obj.updateSingle) {
            updateTempSet(obj, data, function(err) {
                callback(err);
            });
        } else {
            callback();
        } // end if
    });
} // end updateSet

/**
 * Update object temporary set.
 */
function updateTempSet(obj, data, callback) {
    var id = data[obj.idField];
    var newObjectSet = utils.getNewObjectSet(obj.hashPrefix);

    obj.redisClient.SADD(newObjectSet, id, function(err) {
        callback(err);
    });
} // end updateTempSet

/**
 * Update hash method.
 */
function updateHash(redisClient, hashName, data, debug, callback) {
    logger.debug('Updating %s value: %s...',
            hashName, JSON.stringify(data));
    redisClient.HKEYS(hashName, function(err, keys) {
        if(keys.length !== 0 &&
            keys.length > Object.keys(data).length) {
            logger.debug('Keys count not match, ' +
                'removing hash %s...', hashName);
            redisClient.multi()
                .DEL(hashName)
                .HMSET(hashName, data)
                .exec(function(error, replies) {
                    callback(error);
                }); // end redisClient.multi()
        } else {
            redisClient.HMSET(hashName, data, function(error) {
                callback(error);
            });
        } // end if
    }); // end redisClient.HKEYS
} // end updateHash
